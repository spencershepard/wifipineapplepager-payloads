#!/bin/bash
# Title: Generate Payloads
# Description: Generates MetaPayload reconnaissance payloads from configuration files
# Author: spencershepard (GRIMM)
# Version: 1.0


METAPAYLOAD_DIR="/root/payloads/user/metapayload"
CONFIG_DIR="$METAPAYLOAD_DIR/config"
PAYLOADS_DIR="/root/payloads"
ENV_FILE="$METAPAYLOAD_DIR/.env"

LOG yellow "/\/\ MetaPayload Framework"
LOG "Starting MetaPayload payload generation..."

# Verify config directory exists
if [ ! -d "$CONFIG_DIR" ]; then
    LOG red "Error: Config directory not found at $CONFIG_DIR"
    exit 1
fi

# Function to detect picker type for a variable
detect_picker_type() {
    local var_name="$1"
    local default_value="$2"
    
    # If we have a default value, check its pattern
    if [ -n "$default_value" ]; then
        # IP pattern (basic check)
        if [[ "$default_value" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}(/[0-9]{1,2})?$ ]]; then
            echo "IP_PICKER"
            return
        fi
        
        # MAC pattern
        if [[ "$default_value" =~ ^([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}$ ]]; then
            echo "MAC_PICKER"
            return
        fi
        
        # Numeric pattern
        if [[ "$default_value" =~ ^[0-9]+$ ]]; then
            echo "NUMBER_PICKER"
            return
        fi
    else
        # No default, check variable name
        local upper_name=$(echo "$var_name" | tr '[:lower:]' '[:upper:]')
        
        if [[ "$upper_name" =~ IP|HOST|GATEWAY|SUBNET ]]; then
            echo "IP_PICKER"
            return
        fi
        
        if [[ "$upper_name" =~ MAC ]]; then
            echo "MAC_PICKER"
            return
        fi
    fi
    
    echo "TEXT_PICKER"
}

# Function to generate a payload script
generate_payload() {
    local name="$1"
    local path="$2"
    local command="$3"
    local required_vars="$4"
    local optional_vars="$5"
    local description="$6"
    local author="$7"
    local required_packages="$8"
    
    local payload_dir="$PAYLOADS_DIR/$path"
    local payload_file="$payload_dir/payload.sh"
    
    # Collect all variables for this payload
    local all_vars_list=""
    if [ -n "$required_vars" ] && [ "$required_vars" != "null" ]; then
        all_vars_list=$(echo "$required_vars" | jq -r '.[]' | tr '\n' ' ')
    fi
    if [ -n "$optional_vars" ] && [ "$optional_vars" != "null" ]; then
        all_vars_list="$all_vars_list $(echo "$optional_vars" | jq -r 'keys[]' | tr '\n' ' ')"
    fi
    
    # Create directory structure
    mkdir -p "$payload_dir"
    
    # Start building the payload script
    cat > "$payload_file" << 'PAYLOAD_HEADER'
#!/bin/bash
# Title: {{NAME}}
# Description: {{DESCRIPTION}}
# Author: {{AUTHOR}}
# Version: 1.0
# Generated by MetaPayload

LOG yellow "/\/\ MetaPayload Framework"

METAPAYLOAD_DIR="/root/payloads/user/metapayload"
PAYLOAD_DIR="{{PAYLOAD_DIR}}"
PAYLOAD_ENV="{{PAYLOAD_DIR}}/.env"

# Load global variables
if [ -f "$METAPAYLOAD_DIR/.env" ]; then
    set -a
    source "$METAPAYLOAD_DIR/.env"
    set +a
fi

# Load payload-specific variables
if [ -f "$PAYLOAD_ENV" ]; then
    set -a
    source "$PAYLOAD_ENV"
    set +a
fi

# Trim whitespace from all loaded variables
{{TRIM_VARS}}

# Function to check if variable is global
is_global_var() {
    local var_name="$1"
    grep -q "^${var_name}=" "$METAPAYLOAD_DIR/.env" 2>/dev/null
}

# Function to save variable
save_var() {
    local var_name="$1"
    local var_value="$2"
    
    if is_global_var "$var_name"; then
        # Save to global .env
        if grep -q "^${var_name}=" "$METAPAYLOAD_DIR/.env" 2>/dev/null; then
            sed -i "s|^${var_name}=.*|${var_name}=${var_value}|" "$METAPAYLOAD_DIR/.env"
        else
            echo "${var_name}=${var_value}" >> "$METAPAYLOAD_DIR/.env"
        fi
    else
        # Save to payload .env
        mkdir -p "$PAYLOAD_DIR"
        if grep -q "^${var_name}=" "$PAYLOAD_ENV" 2>/dev/null; then
            sed -i "s|^${var_name}=.*|${var_name}=${var_value}|" "$PAYLOAD_ENV"
        else
            echo "${var_name}=${var_value}" >> "$PAYLOAD_ENV"
        fi
    fi
}

PAYLOAD_HEADER

    # Replace placeholders in header
    sed -i "s|{{NAME}}|${name}|g" "$payload_file"
    sed -i "s|{{DESCRIPTION}}|${description}|g" "$payload_file"
    sed -i "s|{{AUTHOR}}|${author}|g" "$payload_file"
    sed -i "s|{{PAYLOAD_DIR}}|${payload_dir}|g" "$payload_file"
    
    # Add variable trimming code for this payload's variables
    if [ -n "$all_vars_list" ]; then
        cat >> "$payload_file" << 'TRIM_CODE'
for var in {{VAR_LIST}}; do
    if [ -n "${!var}" ]; then
        # Trim leading/trailing whitespace and carriage returns
        eval "export $var=\"\$(echo \"\${!var}\" | tr -d '\\r' | xargs)\""
    fi
done

TRIM_CODE
        sed -i "s|{{VAR_LIST}}|$all_vars_list|g" "$payload_file"
    fi
    
    # Remove the placeholder line
    sed -i '/{{TRIM_VARS}}/d' "$payload_file"
    
    # Build metadata for confirmation dialog
    cat >> "$payload_file" << 'METADATA_START'

# Build metadata string
METADATA="{{DESCRIPTION}}
Author: {{AUTHOR}}"
METADATA_START
    
    sed -i "s|{{DESCRIPTION}}|${description}|g" "$payload_file"
    sed -i "s|{{AUTHOR}}|${author}|g" "$payload_file"
    
    # Add required vars to metadata only if they exist
    if [ -n "$required_vars" ] && [ "$required_vars" != "null" ] && [ "$required_vars" != "[]" ]; then
        local req_var_count=$(echo "$required_vars" | jq 'length')
        if [ "$req_var_count" -gt 0 ]; then
            cat >> "$payload_file" << 'METADATA_REQUIRED_HEADER'

METADATA="$METADATA

Required Variables:"
METADATA_REQUIRED_HEADER
            
            echo "$required_vars" | jq -r '.[]' | while read -r var; do
                echo "METADATA=\"\$METADATA" >> "$payload_file"
                echo "  $var: \${$var:-<not set>}\"" >> "$payload_file"
            done
        fi
    fi
    
    # Add optional vars to metadata only if they exist
    if [ -n "$optional_vars" ] && [ "$optional_vars" != "null" ] && [ "$optional_vars" != "{}" ]; then
        local opt_var_count=$(echo "$optional_vars" | jq 'length')
        if [ "$opt_var_count" -gt 0 ]; then
            cat >> "$payload_file" << 'METADATA_OPTIONAL'

METADATA="$METADATA

Optional Variables:"
METADATA_OPTIONAL
    
            echo "$optional_vars" | jq -r 'to_entries[] | "\(.key)=\(.value)"' | while IFS='=' read -r var default; do
                echo "METADATA=\"\$METADATA" >> "$payload_file"
                echo "  $var: \${$var:-$default}\"" >> "$payload_file"
            done
        fi
    fi
    
    # Confirmation dialog
    cat >> "$payload_file" << 'CONFIRMATION'

# Show confirmation dialog
resp=$(CONFIRMATION_DIALOG "$METADATA")
case $? in
    $DUCKYSCRIPT_REJECTED)
        LOG red "Payload cancelled"
        exit 1
        ;;
    $DUCKYSCRIPT_ERROR)
        LOG red "An error occurred"
        exit 1
        ;;
esac

case "$resp" in
    $DUCKYSCRIPT_USER_DENIED)
        LOG "Payload cancelled by user"
        exit 0
        ;;
esac

CONFIRMATION

    # Add package checking and installation
    if [ -n "$required_packages" ] && [ "$required_packages" != "null" ] && [ "$required_packages" != "[]" ]; then
        cat >> "$payload_file" << 'PKG_CHECK_START'

# Check and install required packages
REQUIRED_PACKAGES=({{PACKAGE_LIST}})
MISSING_PACKAGES=()

LOG "Checking required packages..."
for pkg in "${REQUIRED_PACKAGES[@]}"; do
    if ! opkg list-installed | grep -q "^${pkg} "; then
        LOG yellow "Package not installed: $pkg"
        MISSING_PACKAGES+=("$pkg")
    else
        LOG green "Package installed: $pkg"
    fi
done

if [ ${#MISSING_PACKAGES[@]} -gt 0 ]; then
    pkg_list=$(printf ", %s" "${MISSING_PACKAGES[@]}")
    pkg_list=${pkg_list:2}
    
    resp=$(CONFIRMATION_DIALOG "Missing packages: ${pkg_list}\n\nInstall now?")
    case $? in
        $DUCKYSCRIPT_REJECTED|$DUCKYSCRIPT_ERROR)
            LOG red "Error in dialog"
            exit 1
            ;;
    esac
    
    case "$resp" in
        $DUCKYSCRIPT_USER_CONFIRMED)
            LOG "Installing packages..."
            opkg update
            for pkg in "${MISSING_PACKAGES[@]}"; do
                LOG "Installing $pkg..."
                opkg install "$pkg" 2>&1 | tee /tmp/opkg_install.log
                
                # Check if package is actually installed
                if opkg list-installed | grep -q "^${pkg} "; then
                    LOG green "Successfully installed $pkg"
                else
                    LOG red "Failed to install $pkg (package not found in installed list)"
                    LOG red "$(cat /tmp/opkg_install.log)"
                    exit 1
                fi
            done
            LOG green "All packages installed successfully"
            ;;
        *)
            LOG red "Cannot continue without required packages"
            exit 1
            ;;
    esac
fi

PKG_CHECK_START
        
        # Replace package list placeholder
        local pkg_list=$(echo "$required_packages" | jq -r '.[]' | tr '\n' ' ')
        sed -i "s|{{PACKAGE_LIST}}|$pkg_list|g" "$payload_file"
    fi

    # Add required variable checking
    if [ -n "$required_vars" ] && [ "$required_vars" != "null" ]; then
        echo "$required_vars" | jq -r '.[]' | while read -r var; do
            local picker_type=$(detect_picker_type "$var" "")
            
            cat >> "$payload_file" << VAR_CHECK
# Check required variable: $var
if [ -z "\${$var}" ]; then
    resp=\$($picker_type "Enter $var" "")
    case \$? in
        \$DUCKYSCRIPT_CANCELLED|\$DUCKYSCRIPT_REJECTED|\$DUCKYSCRIPT_ERROR)
            LOG red "Cancelled or error setting $var"
            exit 1
            ;;
    esac
    export $var="\$resp"
    save_var "$var" "\$resp"
fi

VAR_CHECK
        done
    fi
    
    # Add optional variable handling
    if [ -n "$optional_vars" ] && [ "$optional_vars" != "null" ] && [ "$optional_vars" != "{}" ]; then
        # Check if there are actually any optional variables
        local opt_var_count=$(echo "$optional_vars" | jq 'length')
        
        if [ "$opt_var_count" -gt 0 ]; then
            # Add general confirmation for changing optional vars
            cat >> "$payload_file" << 'OPT_VAR_GENERAL'

# Ask if user wants to change any optional variables
change_optional=$(CONFIRMATION_DIALOG "Change optional variables?")
case $? in
    $DUCKYSCRIPT_REJECTED|$DUCKYSCRIPT_ERROR)
        LOG red "Error in dialog"
        exit 1
        ;;
esac

OPT_VAR_GENERAL
        fi

        # Set defaults first
        echo "$optional_vars" | jq -r 'to_entries[] | "\(.key)=\(.value)"' | while IFS='=' read -r var default; do
            cat >> "$payload_file" << OPT_VAR_DEFAULT
# Set default for optional variable: $var
if [ -z "\${$var}" ]; then
    export $var="$default"
fi

OPT_VAR_DEFAULT
        done
        
        if [ "$opt_var_count" -gt 0 ]; then
            # Only ask about individual vars if user confirmed
            cat >> "$payload_file" << 'OPT_VAR_CHECK_START'
# Only ask about individual optional vars if user wants to change them
if [ "$change_optional" == "$DUCKYSCRIPT_USER_CONFIRMED" ]; then
OPT_VAR_CHECK_START
        fi

        echo "$optional_vars" | jq -r 'to_entries[] | "\(.key)=\(.value)"' | while IFS='=' read -r var default; do
            local picker_type=$(detect_picker_type "$var" "$default")
            
            cat >> "$payload_file" << OPT_VAR_CHECK
    # Ask about optional variable: $var
    resp=\$(CONFIRMATION_DIALOG "Change $var? (current: \${$var})")
    case \$? in
        \$DUCKYSCRIPT_REJECTED|\$DUCKYSCRIPT_ERROR)
            LOG red "Error in dialog"
            exit 1
            ;;
    esac
    
    case "\$resp" in
        \$DUCKYSCRIPT_USER_CONFIRMED)
            resp=\$($picker_type "Enter $var" "\${$var}")
            case \$? in
                \$DUCKYSCRIPT_CANCELLED|\$DUCKYSCRIPT_REJECTED|\$DUCKYSCRIPT_ERROR)
                    LOG "Keeping current value for $var"
                    ;;
                *)
                    export $var="\$resp"
                    
                    # Ask if they want to save it
                    save_resp=\$(CONFIRMATION_DIALOG "Save $var for next time?")
                    case \$? in
                        \$DUCKYSCRIPT_REJECTED|\$DUCKYSCRIPT_ERROR)
                            LOG "Using $var for this run only"
                            ;;
                        *)
                            case "\$save_resp" in
                                \$DUCKYSCRIPT_USER_CONFIRMED)
                                    save_var "$var" "\$resp"
                                    LOG green "Saved $var"
                                    ;;
                                \$DUCKYSCRIPT_USER_DENIED)
                                    LOG "Using $var for this run only"
                                    ;;
                            esac
                            ;;
                    esac
                    ;;
            esac
            ;;
    esac

OPT_VAR_CHECK
        done
        
        if [ "$opt_var_count" -gt 0 ]; then
            # Close the if statement
            cat >> "$payload_file" << 'OPT_VAR_CHECK_END'
fi

OPT_VAR_CHECK_END
        fi
    fi
    
    # Add command execution with task management
    cat >> "$payload_file" << 'EXEC_CMD'

# Task Management Setup
TASK_DIR="/root/payloads/user/metapayload/.tasks"
TASK_ID="$(date +%s)_$$"
TASK_LOG="$TASK_DIR/$TASK_ID.log"
TASK_META="$TASK_DIR/$TASK_ID.meta"
MGMT_DIR="/root/payloads/user/metapayload"
BACKGROUNDED=false

mkdir -p "$TASK_DIR"

# Function to create management payload
create_management_payload() {
    local task_id="$1"
    local mgmt_payload_dir="$MGMT_DIR/View_Task_${task_id}"
    local mgmt_payload_file="$mgmt_payload_dir/payload.sh"
    
    mkdir -p "$mgmt_payload_dir"
    
    cat > "$mgmt_payload_file" << 'MGMT_PAYLOAD_EOF'
#!/bin/bash
# Title: Task View TASK_ID_PLACEHOLDER
# Description: Monitor or export task TASK_ID_PLACEHOLDER
# Author: MetaPayload
# Version: 1.0

TASK_DIR="/root/payloads/user/metapayload/.tasks"
MGMT_DIR="/root/payloads/user/metapayload"
TASK_ID="TASK_ID_PLACEHOLDER"
TASK_LOG="$TASK_DIR/$TASK_ID.log"
TASK_META="$TASK_DIR/$TASK_ID.meta"

# Function to recursively find all descendant PIDs
get_descendants() {
    local parent_pid="$1"
    local descendants=""
    
    # Find direct children from /proc
    for proc in /proc/[0-9]*; do
        [ -f "$proc/stat" ] || continue
        # Parse PPID - skip past command name in parentheses to avoid spaces in comm field
        local stat_line=$(cat "$proc/stat" 2>/dev/null)
        [ -z "$stat_line" ] && continue
        # Remove everything up to and including the last ) to get past comm field
        local after_comm="${stat_line##*) }"
        # PPID is the second field after state (state ppid ...)
        local ppid=$(echo "$after_comm" | awk '{print $2}')
        if [ "$ppid" = "$parent_pid" ]; then
            local child_pid=$(basename "$proc")
            descendants="$descendants $child_pid"
            # Recursively get this child's descendants
            local child_descendants=$(get_descendants "$child_pid")
            [ -n "$child_descendants" ] && descendants="$descendants$child_descendants"
        fi
    done
    
    echo "$descendants"
}

# Function to kill a process and all its descendants
kill_process_tree() {
    local pid="$1"
    local signal="${2:-TERM}"
    
    [ -z "$pid" ] && return
    
    # Check if process exists before doing anything
    [ ! -d "/proc/$pid" ] && return
    
    # Get all descendants
    local descendants=$(get_descendants "$pid")
    
    # Debug to persistent file
    echo "[$(date)] kill_process_tree: PID=$pid Signal=$signal Descendants=[$descendants]" >> /tmp/kill_debug.log
    
    # Kill descendants first (deepest first)
    for desc_pid in $descendants; do
        [ -d "/proc/$desc_pid" ] || continue
        echo "[$(date)] Killing descendant: $desc_pid" >> /tmp/kill_debug.log
        kill -$signal "$desc_pid" 2>/dev/null
    done
    
    # Kill the parent last
    if [ -d "/proc/$pid" ]; then
        echo "[$(date)] Killing parent: $pid" >> /tmp/kill_debug.log
        kill -$signal "$pid" 2>/dev/null
    fi
}

# Check if task exists
if [ ! -f "$TASK_META" ]; then
    LOG red "Task not found: $TASK_ID"
    exit 1
fi

# Load task metadata
source "$TASK_META"

# Show task info
LOG purple "Task ID: $TASK_ID"
LOG purple "PID: $TASK_PID"
LOG purple "Command: $TASK_CMD"
LOG purple "Status: $TASK_STATUS"
LOG purple "Started: $TASK_START_TIME"
if [ -n "$TASK_END_TIME" ]; then
    LOG purple "Ended: $TASK_END_TIME"
    if [ -n "$TASK_EXIT_CODE" ]; then
        LOG purple "Exit Code: $TASK_EXIT_CODE"
    fi
fi

# Check if task is still running
TASK_RUNNING=false
if [ -n "$TASK_PID" ] && kill -0 "$TASK_PID" 2>/dev/null; then
    TASK_RUNNING=true
    LOG yellow "Task is currently RUNNING (PID: $TASK_PID)"
fi

LOG "Log tail:"
LOG "$(tail -n 10 "$TASK_LOG")"

LOG yellow "Waiting for input..."
LOG yellow "LEFT:Exit | RIGHT:Export | DOWN:Delete Task"

resp=$(WAIT_FOR_INPUT "Press directional button or B to cancel")
case $? in
    $DUCKYSCRIPT_CANCELLED)
        exit 0
        ;;
    $DUCKYSCRIPT_REJECTED|$DUCKYSCRIPT_ERROR)
        LOG red "Error"
        exit 1
        ;;
esac

case "$resp" in
    "LEFT")
        LOG "Exiting..."
        ;;
    "RIGHT")
        LOG "Export log"
        if [ -f "$TASK_LOG" ]; then
            mkdir -p /root/loot/metapayload
            cp "$TASK_LOG" "/root/loot/metapayload/${TASK_ID}_export.log"
            LOG green "Exported to /root/loot/metapayload/${TASK_ID}_export.log"
        else
            LOG red "No log file found"
        fi
        ;;
    "UP")
        LOG "Exiting..."
        ;;
    "DOWN")
        # Delete task
        LOG "Delete task"
        resp=$(CONFIRMATION_DIALOG "Delete task $TASK_ID?" "This will remove all task data")
        case $? in
            $DUCKYSCRIPT_REJECTED|$DUCKYSCRIPT_ERROR)
                LOG red "Error in dialog"
                ;;
            *)
                case "$resp" in
                    $DUCKYSCRIPT_USER_CONFIRMED)
                        # Kill task if running
                        if [ "$TASK_RUNNING" = true ]; then
                            LOG yellow "Terminating running task (PID: $TASK_PID) and all descendants..."
                            kill_process_tree "$TASK_PID" TERM
                            sleep 1
                            kill_process_tree "$TASK_PID" KILL
                        fi
                        
                        # Remove files
                        rm -f "$TASK_LOG" "$TASK_META"
                        mgmt_payload_dir="$MGMT_DIR/View_Task_${TASK_ID}"
                        rm -rf "$mgmt_payload_dir"
                        LOG green "Task deleted"
                        ;;
                    $DUCKYSCRIPT_USER_DENIED)
                        LOG "Cancelled"
                        ;;
                esac
                ;;
        esac
        ;;
    "B")
        LOG "Cancelled"
        exit 0
        ;;
esac

exit 0
MGMT_PAYLOAD_EOF

    sed -i "s|TASK_ID_PLACEHOLDER|${task_id}|g" "$mgmt_payload_file"
    chmod +x "$mgmt_payload_file"
    LOG green "Created management payload for task $task_id"
}

# Function to handle backgrounding
background_task() {
    BACKGROUNDED=true
    
    # Update metadata to backgrounded status and update PID to the child process
    sed -i "s|^TASK_STATUS=.*|TASK_STATUS=\"backgrounded\"|" "$TASK_META"
    sed -i "s|^TASK_PID=.*|TASK_PID=$CMD_PID|" "$TASK_META"
    
    LOG yellow "Task backgrounded. ID: $TASK_ID"
    LOG yellow "PID: $CMD_PID"
    LOG yellow "Use View_Task_${TASK_ID} payload to monitor or export logs"
    
    # Create management payload
    create_management_payload "$TASK_ID"
    
    # Exit parent shell, let child continue
    exit 0
}

# Execute command
EXEC_CMD
    
    # Properly escape the command for the payload script
    printf 'CMD="%s"\n' "$command" >> "$payload_file"
    
    cat >> "$payload_file" << 'EXEC_CMD_END'

# Initialize task metadata
cat > "$TASK_META" << META_EOF
TASK_ID="$TASK_ID"
TASK_CMD="$CMD"
TASK_STATUS="running"
TASK_START_TIME="$(date '+%Y-%m-%d %H:%M:%S')"
TASK_END_TIME=""
TASK_PID=$$
META_EOF

LOG purple "$CMD"
echo "=== Command: $CMD ===" > "$TASK_LOG"
echo "=== Started: $(date '+%Y-%m-%d %H:%M:%S') ===" >> "$TASK_LOG"
echo "" >> "$TASK_LOG"

LOG cyan "[Task Output - LEFT:background ]"
LOG yellow "B will orphan the task!"

# Execute command in background with output streaming and completion handling
(
    eval "$CMD" 2>&1 | while IFS= read -r line; do
        echo "$line" >> "$TASK_LOG"
        LOG "$line"
    done
    exit_code=${PIPESTATUS[0]}
    echo "$exit_code" > "$TASK_DIR/$TASK_ID.exit"
    
    # Check if task was backgrounded and send alert on completion
    if [ -f "$TASK_META" ]; then
        source "$TASK_META"
        if [ "$TASK_STATUS" = "backgrounded" ]; then
            # Update metadata with completion
            echo "" >> "$TASK_LOG"
            echo "=== Ended: $(date '+%Y-%m-%d %H:%M:%S') ===" >> "$TASK_LOG"
            echo "=== Exit Code: $exit_code ===" >> "$TASK_LOG"
            
            sed -i "s|^TASK_STATUS=.*|TASK_STATUS=\"completed\"|" "$TASK_META"
            echo "TASK_END_TIME=\"$(date '+%Y-%m-%d %H:%M:%S')\"" >> "$TASK_META"
            echo "TASK_EXIT_CODE=$exit_code" >> "$TASK_META"
            
            # Send alert for backgrounded task completion
            if [ $exit_code -eq 0 ]; then
                ALERT "Task $TASK_ID completed successfully"
            else
                ALERT "Task $TASK_ID completed with errors (Exit $exit_code)"
            fi
        fi
    fi
    
    exit $exit_code
) &

CMD_PID=$!

# Background process to monitor for button input
(
    while kill -0 $CMD_PID 2>/dev/null; do
        button=$(WAIT_FOR_INPUT 2>/dev/null)
        button_exit=$?
        
        if [ $button_exit -eq 0 ]; then
            case "$button" in
                "LEFT")
                    # Signal parent to background
                    touch "$TASK_DIR/$TASK_ID.background"
                    break
                    ;;
                "B")
                    # Signal parent to terminate
                    touch "$TASK_DIR/$TASK_ID.terminate"
                    break
                    ;;
            esac
        fi
    done
) &
INPUT_PID=$!

# Monitor for completion or signal files
while kill -0 $CMD_PID 2>/dev/null; do
    # Check for background signal
    if [ -f "$TASK_DIR/$TASK_ID.background" ]; then
        rm -f "$TASK_DIR/$TASK_ID.background"
        kill $INPUT_PID 2>/dev/null
        wait $INPUT_PID 2>/dev/null
        background_task
    fi
    
    # Check for terminate signal
    if [ -f "$TASK_DIR/$TASK_ID.terminate" ]; then
        rm -f "$TASK_DIR/$TASK_ID.terminate"
        LOG yellow "Exiting (task will continue)..."
        kill $INPUT_PID 2>/dev/null
        wait $INPUT_PID 2>/dev/null
        EXIT_CODE=130
        break
    fi
    
    sleep 0.2
done

# Cleanup input monitor
kill $INPUT_PID 2>/dev/null
wait $INPUT_PID 2>/dev/null

# Wait for command completion if not backgrounded
if [ "$BACKGROUNDED" = false ]; then
    wait $CMD_PID 2>/dev/null
    
    # Get exit code from file
    if [ -f "$TASK_DIR/$TASK_ID.exit" ]; then
        EXIT_CODE=$(cat "$TASK_DIR/$TASK_ID.exit")
        rm -f "$TASK_DIR/$TASK_ID.exit"
    else
        EXIT_CODE=$?
    fi
    
    # Update metadata with completion
    echo "" >> "$TASK_LOG"
    echo "=== Ended: $(date '+%Y-%m-%d %H:%M:%S') ===" >> "$TASK_LOG"
    echo "=== Exit Code: $EXIT_CODE ===" >> "$TASK_LOG"
    
    cat >> "$TASK_META" << META_END_EOF
TASK_END_TIME="$(date '+%Y-%m-%d %H:%M:%S')"
TASK_STATUS="completed"
TASK_EXIT_CODE=$EXIT_CODE
META_END_EOF
    
    # Log results
    if [ $EXIT_CODE -eq 0 ]; then
        LOG green "══ Task Complete: Exit $EXIT_CODE (Success) ══"
    else
        LOG red "══ Task Complete: Exit $EXIT_CODE (Failed) ══"
    fi
    
    # Create management payload for viewing logs
    create_management_payload "$TASK_ID"
    
    # Post-completion menu
    LOG yellow "Waiting for input..."
    LOG yellow "LEFT:Exit | RIGHT:Export | DOWN:Delete Task"
    
    resp=$(WAIT_FOR_INPUT)
    case $? in
        $DUCKYSCRIPT_CANCELLED)
            exit $EXIT_CODE
            ;;
        $DUCKYSCRIPT_REJECTED|$DUCKYSCRIPT_ERROR)
            LOG red "Error"
            exit $EXIT_CODE
            ;;
    esac
    
    case "$resp" in
        "LEFT")
            LOG "Exiting"
            ;;
        "RIGHT")
            LOG "Exporting log to loot..."
            # Export log
            mkdir -p /root/loot/metapayload
            cp "$TASK_LOG" "/root/loot/metapayload/${TASK_ID}_export.log"
            LOG green "Exported to /root/loot/metapayload/${TASK_ID}_export.log"
            WAIT_FOR_BUTTON_PRESS
            ;;
        "DOWN")
            # Delete task
            LOG "Delete task"
            resp=$(CONFIRMATION_DIALOG "Delete this task?" "This will remove all task data")
            case $? in
                $DUCKYSCRIPT_REJECTED|$DUCKYSCRIPT_ERROR)
                    LOG red "Error in dialog"
                    ;;
                *)
                    case "$resp" in
                        $DUCKYSCRIPT_USER_CONFIRMED)
                            rm -f "$TASK_LOG" "$TASK_META"
                            mgmt_payload_dir="$MGMT_DIR/View_Task_${TASK_ID}"
                            rm -rf "$mgmt_payload_dir"
                            LOG green "Task deleted"
                            ;;
                        $DUCKYSCRIPT_USER_DENIED)
                            LOG "Cancelled"
                            ;;
                    esac
                    ;;
            esac
            ;;
        "B")
            LOG "Exiting"
            ;;
    esac
    
    exit $EXIT_CODE
fi
EXEC_CMD_END

    chmod +x "$payload_file"
    LOG green "Generated: $path"
    
}

# Function to generate Set_Variables payloads
generate_set_variable_payload() {
    local var_name="$1"
    local payload_dir="$METAPAYLOAD_DIR/Set_$var_name"
    local payload_file="$payload_dir/payload.sh"
    
    mkdir -p "$payload_dir"
    
    cat > "$payload_file" << 'SET_VAR_SCRIPT'
#!/bin/bash
# Title: Set {{VAR_NAME}}
# Description: Set global variable {{VAR_NAME}}
# Author: MetaPayload
# Version: 1.0

METAPAYLOAD_DIR="/root/payloads/user/metapayload"
VAR_NAME="{{VAR_NAME}}"

# Load current value
if [ -f "$METAPAYLOAD_DIR/.env" ]; then
    source "$METAPAYLOAD_DIR/.env"
fi

CURRENT_VALUE="${!VAR_NAME}"

# Determine picker type
{{PICKER_LOGIC}}

# Prompt for new value
resp=$($PICKER_TYPE "Enter $VAR_NAME" "$CURRENT_VALUE")
case $? in
    $DUCKYSCRIPT_CANCELLED)
        LOG "Cancelled"
        exit 0
        ;;
    $DUCKYSCRIPT_REJECTED|$DUCKYSCRIPT_ERROR)
        LOG red "Error setting variable"
        exit 1
        ;;
esac

# Save to global .env
if grep -q "^${VAR_NAME}=" "$METAPAYLOAD_DIR/.env" 2>/dev/null; then
    sed -i "s|^${VAR_NAME}=.*|${VAR_NAME}=${resp}|" "$METAPAYLOAD_DIR/.env"
else
    echo "${VAR_NAME}=${resp}" >> "$METAPAYLOAD_DIR/.env"
fi

LOG green "Set $VAR_NAME=$resp"
exit 0
SET_VAR_SCRIPT

    # Detect picker type for this variable
    local picker_type=$(detect_picker_type "$var_name" "")
    local picker_logic="PICKER_TYPE=\"$picker_type\""
    
    sed -i "s|{{VAR_NAME}}|${var_name}|g" "$payload_file"
    sed -i "s|{{PICKER_LOGIC}}|${picker_logic}|g" "$payload_file"
    
    chmod +x "$payload_file"
}

# Extract all unique variables from all configs
declare -A ALL_VARS
for config_file in "$CONFIG_DIR"/*.json; do
    if [ ! -f "$config_file" ]; then
        continue
    fi
    
    LOG "Processing config: $(basename "$config_file")"
    
    # Read payloads from config
    payload_count=$(jq '.payloads | length' "$config_file")
    
    for ((i=0; i<$payload_count; i++)); do
        # Extract payload data
        name=$(jq -r ".payloads[$i].name" "$config_file")
        path=$(jq -r ".payloads[$i].path" "$config_file")
        command=$(jq -r ".payloads[$i].command" "$config_file")
        required_vars=$(jq -c ".payloads[$i].required_vars" "$config_file")
        optional_vars=$(jq -c ".payloads[$i].optional_vars" "$config_file")
        description=$(jq -r ".payloads[$i].description" "$config_file")
        author=$(jq -r ".payloads[$i].author" "$config_file")
        required_packages=$(jq -c ".payloads[$i].required_packages" "$config_file")
        
        # Collect variables
        if [ "$required_vars" != "null" ]; then
            echo "$required_vars" | jq -r '.[]' | while read -r var; do
                ALL_VARS["$var"]=1
            done
        fi
        
        if [ "$optional_vars" != "null" ]; then
            echo "$optional_vars" | jq -r 'keys[]' | while read -r var; do
                ALL_VARS["$var"]=1
            done
        fi
        
        # Generate the payload
        generate_payload "$name" "$path" "$command" "$required_vars" "$optional_vars" "$description" "$author" "$required_packages" 
    done
done

# Initialize .env if it doesn't exist
if [ ! -f "$ENV_FILE" ]; then
    LOG "Creating global .env file from example.env..."
    if [ -f "$METAPAYLOAD_DIR/example.env" ]; then
        # Copy and trim whitespace/line endings from values
        while IFS='=' read -r key value; do
            # Skip empty lines and comments
            [[ -z "$key" || "$key" =~ ^# ]] && continue
            # Trim whitespace and carriage returns from value
            value=$(echo "$value" | tr -d '\r' | xargs)
            echo "${key}=${value}" >> "$ENV_FILE"
        done < "$METAPAYLOAD_DIR/example.env"
        LOG green "Created .env from example.env"
    else
        LOG red "Warning: example.env not found at $METAPAYLOAD_DIR/example.env"
        exit 1
    fi
else
    LOG "Global .env already exists"
fi

# Generate Set_Variables payloads for all vars in .env
LOG "Generating Set_Variables payloads..."
if [ -f "$ENV_FILE" ]; then
    while IFS='=' read -r var_name _; do
        if [ -n "$var_name" ] && [[ ! "$var_name" =~ ^# ]]; then
            generate_set_variable_payload "$var_name"
        fi
    done < "$ENV_FILE"
fi

LOG green "Payload generation complete!"
exit 0
