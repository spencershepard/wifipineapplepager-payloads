#!/bin/bash
# Title: Generate Payloads
# Description: Generates MetaPayload reconnaissance payloads from configuration files
# Author: spencershepard (GRIMM)
# Version: 1.1


METAPAYLOAD_DIR="/root/payloads/user/metapayload"
CONFIG_DIR="$METAPAYLOAD_DIR/config"
PAYLOADS_DIR="/root/payloads"
ENV_FILE="$METAPAYLOAD_DIR/.env"

LOG yellow "/\/\ MetaPayload Framework"
LOG "Starting MetaPayload payload generation..."

# Verify config directory exists
if [ ! -d "$CONFIG_DIR" ]; then
    LOG red "Error: Config directory not found at $CONFIG_DIR"
    exit 1
fi

# Function to detect picker type for a variable
detect_picker_type() {
    local var_name="$1"
    local default_value="$2"
    
    # If we have a default value, check its pattern
    if [ -n "$default_value" ]; then
        # IP pattern (basic check)
        if [[ "$default_value" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}(/[0-9]{1,2})?$ ]]; then
            echo "IP_PICKER"
            return
        fi
        
        # MAC pattern
        if [[ "$default_value" =~ ^([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}$ ]]; then
            echo "MAC_PICKER"
            return
        fi
        
        # Numeric pattern
        if [[ "$default_value" =~ ^[0-9]+$ ]]; then
            echo "NUMBER_PICKER"
            return
        fi
    else
        # No default, check variable name
        local upper_name=$(echo "$var_name" | tr '[:lower:]' '[:upper:]')
        
        if [[ "$upper_name" =~ IP|HOST|GATEWAY|SUBNET ]]; then
            echo "IP_PICKER"
            return
        fi
        
        if [[ "$upper_name" =~ MAC ]]; then
            echo "MAC_PICKER"
            return
        fi
    fi
    
    echo "TEXT_PICKER"
}

# Function to generate a payload script
generate_payload() {
    local name="$1"
    local path="$2"
    local command="$3"
    local required_vars="$4"
    local optional_vars="$5"
    local description="$6"
    local author="$7"
    local required_packages="$8"
    
    local payload_dir="$PAYLOADS_DIR/$path"
    local payload_file="$payload_dir/payload.sh"
    
    # Collect all variables for this payload
    local all_vars_list=""
    if [ -n "$required_vars" ] && [ "$required_vars" != "null" ]; then
        all_vars_list=$(echo "$required_vars" | jq -r '.[]' | tr '\n' ' ')
    fi
    if [ -n "$optional_vars" ] && [ "$optional_vars" != "null" ]; then
        all_vars_list="$all_vars_list $(echo "$optional_vars" | jq -r 'keys[]' | tr '\n' ' ')"
    fi
    
    # Create directory structure
    mkdir -p "$payload_dir"
    
    # Start building the payload script
    cat > "$payload_file" << 'PAYLOAD_HEADER'
#!/bin/bash
# Title: {{NAME}}
# Description: {{DESCRIPTION}}
# Author: {{AUTHOR}}
# Version: 1.0
# Generated by MetaPayload

LOG yellow "/\/\ MetaPayload Framework"

METAPAYLOAD_DIR="/root/payloads/user/metapayload"
PAYLOAD_DIR="{{PAYLOAD_DIR}}"
PAYLOAD_ENV="{{PAYLOAD_DIR}}/.env"

# Load global variables
if [ -f "$METAPAYLOAD_DIR/.env" ]; then
    set -a
    source "$METAPAYLOAD_DIR/.env"
    set +a
fi

# Load payload-specific variables
if [ -f "$PAYLOAD_ENV" ]; then
    set -a
    source "$PAYLOAD_ENV"
    set +a
fi

# Trim whitespace from all loaded variables
{{TRIM_VARS}}

# Function to check if variable is global
is_global_var() {
    local var_name="$1"
    grep -q "^${var_name}=" "$METAPAYLOAD_DIR/.env" 2>/dev/null
}

# Function to save variable
save_var() {
    local var_name="$1"
    local var_value="$2"
    
    if is_global_var "$var_name"; then
        # Save to global .env
        if grep -q "^${var_name}=" "$METAPAYLOAD_DIR/.env" 2>/dev/null; then
            sed -i "s|^${var_name}=.*|${var_name}=${var_value}|" "$METAPAYLOAD_DIR/.env"
        else
            echo "${var_name}=${var_value}" >> "$METAPAYLOAD_DIR/.env"
        fi
    else
        # Save to payload .env
        mkdir -p "$PAYLOAD_DIR"
        if grep -q "^${var_name}=" "$PAYLOAD_ENV" 2>/dev/null; then
            sed -i "s|^${var_name}=.*|${var_name}=${var_value}|" "$PAYLOAD_ENV"
        else
            echo "${var_name}=${var_value}" >> "$PAYLOAD_ENV"
        fi
    fi
}

# Function to prompt and save a variable
prompt_and_save_variable() {
    local var_name="$1"
    local picker_type="$2"
    local prompt_msg="$3"
    local current_value="${!var_name}"
    
    resp=$(${picker_type} "${prompt_msg}" "${current_value}")
    case $? in
        $DUCKYSCRIPT_CANCELLED|$DUCKYSCRIPT_REJECTED|$DUCKYSCRIPT_ERROR)
            return 1
            ;;
        *)
            export ${var_name}="${resp}"
            
            # Check if this is a global variable
            if grep -q "^${var_name}=" "$METAPAYLOAD_DIR/.env" 2>/dev/null; then
                # Global variable - ask to update globally or use once
                save_resp=$(CONFIRMATION_DIALOG "Update global ${var_name}?" "YES: Update global variable\nNO: Use for this run only")
                case $? in
                    $DUCKYSCRIPT_REJECTED|$DUCKYSCRIPT_ERROR)
                        LOG "Using ${var_name} for this run only"
                        ;;
                    *)
                        case "$save_resp" in
                            $DUCKYSCRIPT_USER_CONFIRMED)
                                sed -i "s|^${var_name}=.*|${var_name}=${resp}|" "$METAPAYLOAD_DIR/.env"
                                LOG green "Updated global ${var_name}"
                                ;;
                            $DUCKYSCRIPT_USER_DENIED)
                                LOG "Using ${var_name} for this run only"
                                ;;
                        esac
                        ;;
                esac
            else
                # Local variable - ask to save locally or use once
                save_resp=$(CONFIRMATION_DIALOG "Save ${var_name}?" "YES: Save for this payload\nNO: Use for this run only")
                case $? in
                    $DUCKYSCRIPT_REJECTED|$DUCKYSCRIPT_ERROR)
                        LOG "Using ${var_name} for this run only"
                        ;;
                    *)
                        case "$save_resp" in
                            $DUCKYSCRIPT_USER_CONFIRMED)
                                mkdir -p "$PAYLOAD_DIR"
                                if grep -q "^${var_name}=" "$PAYLOAD_ENV" 2>/dev/null; then
                                    sed -i "s|^${var_name}=.*|${var_name}=${resp}|" "$PAYLOAD_ENV"
                                else
                                    echo "${var_name}=${resp}" >> "$PAYLOAD_ENV"
                                fi
                                LOG green "Saved ${var_name} locally"
                                ;;
                            $DUCKYSCRIPT_USER_DENIED)
                                LOG "Using ${var_name} for this run only"
                                ;;
                        esac
                        ;;
                esac
            fi
            return 0
            ;;
    esac
}

PAYLOAD_HEADER

    # Replace placeholders in header
    sed -i "s|{{NAME}}|${name}|g" "$payload_file"
    sed -i "s|{{DESCRIPTION}}|${description}|g" "$payload_file"
    sed -i "s|{{AUTHOR}}|${author}|g" "$payload_file"
    sed -i "s|{{PAYLOAD_DIR}}|${payload_dir}|g" "$payload_file"
    
    local sanitized_name=$(echo "$name" | tr -s ' ' '_' | tr -cd 'A-Za-z0-9_' | sed 's/__*/_/g; s/^_//; s/_$//')
    
    # Add variable trimming code for this payload's variables
    if [ -n "$all_vars_list" ]; then
        cat >> "$payload_file" << 'TRIM_CODE'
for var in {{VAR_LIST}}; do
    if [ -n "${!var}" ]; then
        # Trim leading/trailing whitespace and carriage returns
        eval "export $var=\"\$(echo \"\${!var}\" | tr -d '\\r' | xargs)\""
    fi
done

TRIM_CODE
        sed -i "s|{{VAR_LIST}}|$all_vars_list|g" "$payload_file"
    fi
    
    # Remove the placeholder line
    sed -i '/{{TRIM_VARS}}/d' "$payload_file"
    
    # Build metadata for confirmation dialog
    cat >> "$payload_file" << 'METADATA_START'

# Build metadata string (just names, no values)
METADATA="{{DESCRIPTION}}"
METADATA_START
    
    sed -i "s|{{DESCRIPTION}}|${description}|g" "$payload_file"
    
    # Add required var names (without values) to metadata
    if [ -n "$required_vars" ] && [ "$required_vars" != "null" ] && [ "$required_vars" != "[]" ]; then
        local req_var_count=$(echo "$required_vars" | jq 'length')
        if [ "$req_var_count" -gt 0 ]; then
            cat >> "$payload_file" << 'METADATA_REQUIRED_HEADER'

METADATA="$METADATA
"
METADATA_REQUIRED_HEADER
            echo "Required:" >> "$payload_file"
            echo "$required_vars" | jq -r '.[]' | while read -r var; do
                echo "METADATA=\"\$METADATA" >> "$payload_file"
                echo "[$var]\"" >> "$payload_file"
            done
        fi
    fi
    
    # Confirmation dialog
    cat >> "$payload_file" << 'CONFIRMATION'

# Show confirmation dialog
resp=$(CONFIRMATION_DIALOG "$METADATA")
case $? in
    $DUCKYSCRIPT_REJECTED)
        LOG red "Payload cancelled"
        exit 1
        ;;
    $DUCKYSCRIPT_ERROR)
        LOG red "An error occurred"
        exit 1
        ;;
esac

case "$resp" in
    $DUCKYSCRIPT_USER_DENIED)
        LOG "Payload cancelled by user"
        exit 0
        ;;
esac

CONFIRMATION

    # Add package checking and installation
    if [ -n "$required_packages" ] && [ "$required_packages" != "null" ] && [ "$required_packages" != "[]" ]; then
        cat >> "$payload_file" << 'PKG_CHECK_START'

# Check and install required packages
REQUIRED_PACKAGES=({{PACKAGE_LIST}})
MISSING_PACKAGES=()

LOG purple "Checking required packages..."
for pkg in "${REQUIRED_PACKAGES[@]}"; do
    if ! opkg list-installed | grep -q "^${pkg} "; then
        LOG yellow "Package not installed: $pkg"
        MISSING_PACKAGES+=("$pkg")
    else
        LOG purple "Package installed: $pkg"
    fi
done

if [ ${#MISSING_PACKAGES[@]} -gt 0 ]; then
    pkg_list=$(printf ", %s" "${MISSING_PACKAGES[@]}")
    pkg_list=${pkg_list:2}
    
    resp=$(CONFIRMATION_DIALOG "Missing packages: ${pkg_list}\n\nInstall now?")
    case $? in
        $DUCKYSCRIPT_REJECTED|$DUCKYSCRIPT_ERROR)
            LOG red "Error in dialog"
            exit 1
            ;;
    esac
    
    case "$resp" in
        $DUCKYSCRIPT_USER_CONFIRMED)
            LOG "Installing packages..."
            opkg update
            for pkg in "${MISSING_PACKAGES[@]}"; do
                LOG "Installing $pkg..."
                opkg install "$pkg" 2>&1 | tee /tmp/opkg_install.log
                
                # Check if package is actually installed
                if opkg list-installed | grep -q "^${pkg} "; then
                    LOG green "Successfully installed $pkg"
                else
                    LOG red "Failed to install $pkg (package not found in installed list)"
                    LOG red "$(cat /tmp/opkg_install.log)"
                    exit 1
                fi
            done
            LOG green "All packages installed successfully"
            ;;
        *)
            LOG red "Cannot continue without required packages"
            exit 1
            ;;
    esac
fi

PKG_CHECK_START
        
        # Replace package list placeholder
        local pkg_list=$(echo "$required_packages" | jq -r '.[]' | tr '\n' ' ')
        sed -i "s|{{PACKAGE_LIST}}|$pkg_list|g" "$payload_file"
    fi

    # Check if there are any variables at all
    local has_vars=false
    if ([ -n "$required_vars" ] && [ "$required_vars" != "null" ] && [ "$required_vars" != "[]" ]) || 
       ([ -n "$optional_vars" ] && [ "$optional_vars" != "null" ] && [ "$optional_vars" != "{}" ]); then
        has_vars=true
    fi
    
    # Set defaults for required variables (empty string)
    if [ -n "$required_vars" ] && [ "$required_vars" != "null" ] && [ "$required_vars" != "[]" ]; then
        echo "$required_vars" | jq -r '.[]' | while read -r var; do
            cat >> "$payload_file" << REQ_VAR_DEFAULT
# Set default for required variable: $var (must be set)
if [ -z "\${$var}" ]; then
    export $var=""
fi

REQ_VAR_DEFAULT
        done
    fi
    
    # Set defaults for optional variables
    if [ -n "$optional_vars" ] && [ "$optional_vars" != "null" ] && [ "$optional_vars" != "{}" ]; then

        # Set defaults for optional variables
        echo "$optional_vars" | jq -r 'to_entries[] | "\(.key)=\(.value)"' | while IFS='=' read -r var default; do
            cat >> "$payload_file" << OPT_VAR_DEFAULT
# Set default for optional variable: $var
if [ -z "\${$var}" ]; then
    export $var="$default"
fi

OPT_VAR_DEFAULT
        done
    fi
    
    # PHASE 1: Handle unset required variables immediately
    if [ -n "$required_vars" ] && [ "$required_vars" != "null" ] && [ "$required_vars" != "[]" ]; then
        echo "$required_vars" | jq -r '.[]' | while read -r var; do
            local picker_type=$(detect_picker_type "$var" "")
            
            cat >> "$payload_file" << REQ_VAR_IMMEDIATE
# Check if required variable $var is unset - prompt immediately
if [ -z "\${$var}" ]; then
    if ! prompt_and_save_variable "$var" "$picker_type" "Enter $var (required)"; then
        LOG red "Required variable $var must be set"
        exit 1
    fi
fi

REQ_VAR_IMMEDIATE
        done
    fi
    
    # PHASE 2: Ask if user wants to change any variables (if there are any)
    if [ "$has_vars" = true ]; then
        cat >> "$payload_file" << 'VAR_CHANGE_PROMPT'

# Build detailed metadata with all variables and values
DETAILED_METADATA=""
VAR_CHANGE_PROMPT

        # Add required vars with values to detailed metadata
        if [ -n "$required_vars" ] && [ "$required_vars" != "null" ] && [ "$required_vars" != "[]" ]; then
            echo "$required_vars" | jq -r '.[]' | while read -r var; do
                echo "DETAILED_METADATA=\"\$DETAILED_METADATA" >> "$payload_file"
                echo "  [$var]: \${$var}\"" >> "$payload_file"
            done
        fi
        
        # Add optional vars with values to detailed metadata
        if [ -n "$optional_vars" ] && [ "$optional_vars" != "null" ] && [ "$optional_vars" != "{}" ]; then
            echo "$optional_vars" | jq -r 'to_entries[] | "\(.key)=\(.value)"' | while IFS='=' read -r var default; do
                echo "DETAILED_METADATA=\"\$DETAILED_METADATA" >> "$payload_file"
                echo "  $var: \${$var}\"" >> "$payload_file"
            done
        fi
        
        cat >> "$payload_file" << 'VAR_CHANGE_DIALOG'

# Ask if user wants to change any variables
change_vars=$(CONFIRMATION_DIALOG "$DETAILED_METADATA" "

Change variables?")
case $? in
    $DUCKYSCRIPT_REJECTED|$DUCKYSCRIPT_ERROR)
        LOG red "Error in dialog"
        exit 1
        ;;
esac

if [ "$change_vars" == "$DUCKYSCRIPT_USER_CONFIRMED" ]; then
VAR_CHANGE_DIALOG
    
        # Handle required variables (that are already set)
        if [ -n "$required_vars" ] && [ "$required_vars" != "null" ] && [ "$required_vars" != "[]" ]; then
            echo "$required_vars" | jq -r '.[]' | while read -r var; do
                local picker_type=$(detect_picker_type "$var" "")
                local var_label="$var (required)"
                
                cat >> "$payload_file" << REQ_VAR_CHANGE
    # Ask about required variable: $var
    resp=\$(CONFIRMATION_DIALOG "Change $var_label? (current: \${$var})")
    case \$? in
        \$DUCKYSCRIPT_REJECTED|\$DUCKYSCRIPT_ERROR)
            LOG red "Error in dialog"
            exit 1
            ;;
    esac
    
    case "\$resp" in
        \$DUCKYSCRIPT_USER_CONFIRMED)
            if ! prompt_and_save_variable "$var" "$picker_type" "Enter $var"; then
                LOG "Keeping current value for $var"
            fi
            ;;
    esac

REQ_VAR_CHANGE
            done
        fi
        
        # Handle optional variables
        if [ -n "$optional_vars" ] && [ "$optional_vars" != "null" ] && [ "$optional_vars" != "{}" ]; then
            echo "$optional_vars" | jq -r 'to_entries[] | "\(.key)=\(.value)"' | while IFS='=' read -r var default; do
                local picker_type=$(detect_picker_type "$var" "$default")
                
                cat >> "$payload_file" << OPT_VAR_CHANGE
    # Ask about optional variable: $var
    resp=\$(CONFIRMATION_DIALOG "Change $var? (current: \${$var})")
    case \$? in
        \$DUCKYSCRIPT_REJECTED|\$DUCKYSCRIPT_ERROR)
            LOG red "Error in dialog"
            exit 1
            ;;
    esac
    
    case "\$resp" in
        \$DUCKYSCRIPT_USER_CONFIRMED)
            if ! prompt_and_save_variable "$var" "$picker_type" "Enter $var"; then
                LOG "Keeping current value for $var"
            fi
            ;;
    esac

OPT_VAR_CHANGE
            done
        fi
        
        # Close the variable change block
        cat >> "$payload_file" << 'VAR_CHANGE_END'
fi

# Validate required variables are set
VAR_CHANGE_END
        
        # Add validation for required variables
        if [ -n "$required_vars" ] && [ "$required_vars" != "null" ] && [ "$required_vars" != "[]" ]; then
            echo "$required_vars" | jq -r '.[]' | while read -r var; do
                cat >> "$payload_file" << REQ_VAR_VALIDATE
if [ -z "\${$var}" ]; then
    LOG red "Required variable $var is not set"
    exit 1
fi
REQ_VAR_VALIDATE
            done
            
            cat >> "$payload_file" << 'VAR_VALIDATE_END'

VAR_VALIDATE_END
        fi
    fi
    
    # Add command execution with task management
    cat >> "$payload_file" << 'EXEC_CMD'

# Task Management Setup
METAPAYLOAD_DIR="/root/payloads/user/metapayload"
TASK_DIR="$METAPAYLOAD_DIR/.tasks"
PAYLOAD_NAME="{{PAYLOAD_NAME_SANITIZED}}"
COUNTER_FILE="$TASK_DIR/.counter"

mkdir -p "$TASK_DIR"

# Read and increment task counter atomically (for unique task IDs)
(
    flock -x 200
    
    # Read current counter (default to 0)
    COUNTER=0
    if [ -f "$COUNTER_FILE" ]; then
        COUNTER=$(cat "$COUNTER_FILE")
    fi
    
    # Increment and write back
    COUNTER=$((COUNTER + 1))
    echo "$COUNTER" > "$COUNTER_FILE"
    
    # Output counter for use in main script
    echo "$COUNTER"
) 200>"$TASK_DIR/.counter.lock"

COUNTER=$(cat "$COUNTER_FILE")

TASK_ID="$(printf '%02d' $COUNTER)-${PAYLOAD_NAME}"
TASK_LOG="$TASK_DIR/$TASK_ID.log"
TASK_META="$TASK_DIR/$TASK_ID.meta"
MGMT_DIR="/root/payloads/user/metapayload"
BACKGROUNDED=false

# Function to create management payload
create_management_payload() {
    local task_id="$1"
    local mgmt_payload_dir="$MGMT_DIR/View_Task_${task_id}"
    local mgmt_payload_file="$mgmt_payload_dir/payload.sh"
    
    mkdir -p "$mgmt_payload_dir"
    
    cat > "$mgmt_payload_file" << 'MGMT_PAYLOAD_EOF'
#!/bin/bash
# Title: Task View TASK_ID_PLACEHOLDER
# Description: Monitor or export task TASK_ID_PLACEHOLDER
# Author: MetaPayload
# Version: 1.0

TASK_DIR="/root/payloads/user/metapayload/.tasks"
MGMT_DIR="/root/payloads/user/metapayload"
TASK_ID="TASK_ID_PLACEHOLDER"
TASK_LOG="$TASK_DIR/$TASK_ID.log"
TASK_META="$TASK_DIR/$TASK_ID.meta"

# Function to recursively find all descendant PIDs
get_descendants() {
    local parent_pid="$1"
    local descendants=""
    
    # Find direct children from /proc
    for proc in /proc/[0-9]*; do
        [ -f "$proc/stat" ] || continue
        # Parse PPID - skip past command name in parentheses to avoid spaces in comm field
        local stat_line=$(cat "$proc/stat" 2>/dev/null)
        [ -z "$stat_line" ] && continue
        # Remove everything up to and including the last ) to get past comm field
        local after_comm="${stat_line##*) }"
        # PPID is the second field after state (state ppid ...)
        local ppid=$(echo "$after_comm" | awk '{print $2}')
        if [ "$ppid" = "$parent_pid" ]; then
            local child_pid=$(basename "$proc")
            descendants="$descendants $child_pid"
            # Recursively get this child's descendants
            local child_descendants=$(get_descendants "$child_pid")
            [ -n "$child_descendants" ] && descendants="$descendants$child_descendants"
        fi
    done
    
    echo "$descendants"
}

# Function to kill a process and all its descendants
kill_process_tree() {
    local pid="$1"
    local signal="${2:-TERM}"
    
    [ -z "$pid" ] && return
    
    # Check if process exists before doing anything
    [ ! -d "/proc/$pid" ] && return
    
    # Get all descendants
    local descendants=$(get_descendants "$pid")
    
    # Debug to persistent file
    echo "[$(date)] kill_process_tree: PID=$pid Signal=$signal Descendants=[$descendants]" >> /tmp/kill_debug.log
    
    # Kill descendants first (deepest first)
    for desc_pid in $descendants; do
        [ -d "/proc/$desc_pid" ] || continue
        echo "[$(date)] Killing descendant: $desc_pid" >> /tmp/kill_debug.log
        kill -$signal "$desc_pid" 2>/dev/null
    done
    
    # Kill the parent last
    if [ -d "/proc/$pid" ]; then
        echo "[$(date)] Killing parent: $pid" >> /tmp/kill_debug.log
        kill -$signal "$pid" 2>/dev/null
    fi
}

# Check if task exists
if [ ! -f "$TASK_META" ]; then
    LOG red "Task not found: $TASK_ID"
    exit 1
fi

# Load task metadata
source "$TASK_META"

# Show task info
LOG purple "Task ID: $TASK_ID"
LOG purple "PID: $TASK_PID"
LOG cyan "Command: $TASK_CMD"
LOG purple "Status: $TASK_STATUS"
LOG purple "Started: $TASK_START_TIME"
if [ -n "$TASK_END_TIME" ]; then
    LOG purple "Ended: $TASK_END_TIME"
    if [ -n "$TASK_EXIT_CODE" ]; then
        LOG purple "Exit Code: $TASK_EXIT_CODE"
    fi
fi

# Check if task is still running
TASK_RUNNING=false
if [ -n "$TASK_PID" ] && kill -0 "$TASK_PID" 2>/dev/null; then
    TASK_RUNNING=true
    LOG yellow "Task is currently RUNNING (PID: $TASK_PID)"
fi

LOG "Log tail:"
LOG "$(tail -n 200 "$TASK_LOG")"
LOG ""
LOG yellow "# LEFT:View | RIGHT:Export | DOWN:Delete Task #"
LOG yellow "#->"

resp=$(WAIT_FOR_INPUT "Press directional button or B to cancel")
case $? in
    $DUCKYSCRIPT_CANCELLED)
        exit 0
        ;;
    $DUCKYSCRIPT_REJECTED|$DUCKYSCRIPT_ERROR)
        LOG red "Error"
        exit 1
        ;;
esac

case "$resp" in
    "LEFT")
        RINGTONE leveldone
        LOG cyan "#--> View log"
        ;;
    "RIGHT")
        LOG cyan "#--> Export log"
        if [ -f "$TASK_LOG" ]; then
            LOG blue $(/bin/bash "$MGMT_DIR/scripts/export_task_log.sh" "$TASK_ID" 2>&1) >> "$TASK_LOG"
        else
            LOG red "No log file found"
        fi
        ;;
    "UP")
        RINGTONE leveldone
        ;;
    "DOWN")
        # Delete task
        RINGTONE bonus
        LOG cyan "#--> Delete task..."
        resp=$(CONFIRMATION_DIALOG "Delete task $TASK_ID?" "This will remove all task data and logs.")
        case $? in
            $DUCKYSCRIPT_REJECTED|$DUCKYSCRIPT_ERROR)
                LOG red "Error in dialog"
                ;;
            *)
                case "$resp" in
                    $DUCKYSCRIPT_USER_CONFIRMED)
                        # Kill task if running
                        if [ "$TASK_RUNNING" = true ]; then
                            LOG yellow "Terminating running task (PID: $TASK_PID) and all descendants..."
                            kill_process_tree "$TASK_PID" TERM
                            sleep 1
                            kill_process_tree "$TASK_PID" KILL
                        fi
                        
                        # Remove files
                        rm -f "$TASK_LOG" "$TASK_META"
                        mgmt_payload_dir="$MGMT_DIR/View_Task_${TASK_ID}"
                        rm -rf "$mgmt_payload_dir"
                        LOG green "Task deleted"
                        ;;
                    $DUCKYSCRIPT_USER_DENIED)
                        LOG "Cancelled"
                        ;;
                esac
                ;;
        esac
        ;;
    "B")
        LOG "Cancelled"
        exit 0
        ;;
esac

exit 0
MGMT_PAYLOAD_EOF

    sed -i "s|TASK_ID_PLACEHOLDER|${task_id}|g" "$mgmt_payload_file"
    chmod +x "$mgmt_payload_file"
    LOG green "Created mgmt payload for task $task_id"
}

# Function to handle backgrounding
background_task() {
    BACKGROUNDED=true
    
    # Update metadata to backgrounded status and update PID to the child process
    sed -i "s|^TASK_STATUS=.*|TASK_STATUS=\"backgrounded\"|" "$TASK_META"
    sed -i "s|^TASK_PID=.*|TASK_PID=$CMD_PID|" "$TASK_META"
    
    LOG yellow "Task backgrounded. ID: $TASK_ID"
    LOG yellow "PID: $CMD_PID"
    LOG yellow "Use View_Task_${TASK_ID} payload to monitor or export logs"
    
    # Create management payload
    create_management_payload "$TASK_ID"
    
    # Exit parent shell, let child continue
    exit 0
}

# Execute command
EXEC_CMD
    
    # Replace payload name placeholder in EXEC_CMD section
    sed -i "s|{{PAYLOAD_NAME_SANITIZED}}|${sanitized_name}|g" "$payload_file"
    
    # Replace other placeholders in EXEC_CMD section
    sed -i "s|{{METAPAYLOAD_DIR}}|${METAPAYLOAD_DIR}|g" "$payload_file"
    
    # Properly escape the command for the payload script
    printf 'CMD="%s"\n' "$command" >> "$payload_file"
    
    cat >> "$payload_file" << 'EXEC_CMD_END'

# Initialize task metadata
cat > "$TASK_META" << META_EOF
TASK_ID="$TASK_ID"
TASK_CMD="$CMD"
TASK_STATUS="running"
TASK_START_TIME="$(date '+%Y-%m-%d %H:%M:%S')"
TASK_END_TIME=""
TASK_PID=$$
META_EOF

LOG cyan "$CMD"
echo "=== Command: $CMD ===" > "$TASK_LOG"
echo "=== Started: $(date '+%Y-%m-%d %H:%M:%S') ===" >> "$TASK_LOG"
echo "" >> "$TASK_LOG"

LOG yellow "[ ** PRESS LEFT TO BACKGROUND THE TASK ** ]"

# Execute command in background with output streaming and completion handling
(
    eval "$CMD" 2>&1 | while IFS= read -r line; do
        echo "$line" >> "$TASK_LOG"
        LOG "$line"
    done
    exit_code=${PIPESTATUS[0]}
    echo "$exit_code" > "$TASK_DIR/$TASK_ID.exit"
    
    # Check if task was backgrounded and send alert on completion
    if [ -f "$TASK_META" ]; then
        source "$TASK_META"
        if [ "$TASK_STATUS" = "backgrounded" ]; then
            # Update metadata with completion
            echo "" >> "$TASK_LOG"
            echo "=== Ended: $(date '+%Y-%m-%d %H:%M:%S') ===" >> "$TASK_LOG"
            echo "=== Exit Code: $exit_code ===" >> "$TASK_LOG"
            
            sed -i "s|^TASK_STATUS=.*|TASK_STATUS=\"completed\"|" "$TASK_META"
            echo "TASK_END_TIME=\"$(date '+%Y-%m-%d %H:%M:%S')\"" >> "$TASK_META"
            echo "TASK_EXIT_CODE=$exit_code" >> "$TASK_META"
            
            # Send alert for backgrounded task completion
            if [ $exit_code -eq 0 ]; then
                ALERT "Task $TASK_ID completed successfully"
                RINGTONE leveldone
            else
                ALERT "Task $TASK_ID completed with errors (Exit $exit_code)"
                RINGTONE error
            fi
        fi
    fi
    
    exit $exit_code
) &

CMD_PID=$!

# Background process to monitor for button input
(
    while kill -0 $CMD_PID 2>/dev/null; do
        button=$(WAIT_FOR_INPUT 2>/dev/null)
        button_exit=$?
        
        # Handle button press regardless of exit code to avoid missing inputs
        case "$button" in
            "LEFT")
                # Signal parent to background
                RINGTONE getkey
                touch "$TASK_DIR/$TASK_ID.background"
                break
                ;;
            "B")
                # Signal parent to terminate
                RINGTONE bonus
                touch "$TASK_DIR/$TASK_ID.terminate"
                break
                ;;
            *)
                # If no valid button or error, add small delay to prevent busy-waiting
                if [ $button_exit -ne 0 ] || [ -z "$button" ]; then
                    sleep 0.1
                fi
                ;;
        esac
    done
) &
INPUT_PID=$!

# Monitor for completion or signal files
while kill -0 $CMD_PID 2>/dev/null; do
    # Check for background signal
    if [ -f "$TASK_DIR/$TASK_ID.background" ]; then
        rm -f "$TASK_DIR/$TASK_ID.background"
        kill $INPUT_PID 2>/dev/null
        wait $INPUT_PID 2>/dev/null
        background_task
    fi
    
    # Check for terminate signal
    if [ -f "$TASK_DIR/$TASK_ID.terminate" ]; then
        rm -f "$TASK_DIR/$TASK_ID.terminate"
        LOG yellow "Terminating task..."
        kill $INPUT_PID 2>/dev/null
        wait $INPUT_PID 2>/dev/null
        
        # Kill the command process
        kill $CMD_PID 2>/dev/null
        sleep 0.5
        kill -9 $CMD_PID 2>/dev/null
        
        # Update metadata
        echo "" >> "$TASK_LOG"
        echo "=== Terminated: $(date '+%Y-%m-%d %H:%M:%S') ===" >> "$TASK_LOG"
        
        cat >> "$TASK_META" << META_TERM_EOF
TASK_END_TIME="$(date '+%Y-%m-%d %H:%M:%S')"
TASK_STATUS="terminated"
TASK_EXIT_CODE=130
META_TERM_EOF
        
        LOG red "Task terminated"
        exit 130
    fi
    
    sleep 0.2
done

# Cleanup input monitor
kill $INPUT_PID 2>/dev/null
wait $INPUT_PID 2>/dev/null

# Wait for command completion if not backgrounded
if [ "$BACKGROUNDED" = false ]; then
    wait $CMD_PID 2>/dev/null
    
    # Get exit code from file
    if [ -f "$TASK_DIR/$TASK_ID.exit" ]; then
        EXIT_CODE=$(cat "$TASK_DIR/$TASK_ID.exit")
        rm -f "$TASK_DIR/$TASK_ID.exit"
    else
        EXIT_CODE=$?
    fi
    
    # Update metadata with completion
    echo "" >> "$TASK_LOG"
    echo "=== Ended: $(date '+%Y-%m-%d %H:%M:%S') ===" >> "$TASK_LOG"
    echo "=== Exit Code: $EXIT_CODE ===" >> "$TASK_LOG"
    
    cat >> "$TASK_META" << META_END_EOF
TASK_END_TIME="$(date '+%Y-%m-%d %H:%M:%S')"
TASK_STATUS="completed"
TASK_EXIT_CODE=$EXIT_CODE
META_END_EOF
    
    # Log results
    if [ $EXIT_CODE -eq 0 ]; then
        LOG green "══ Task Complete: Exit $EXIT_CODE (Success) ══"
        RINGTONE leveldone
    else
        LOG red "══ Task Complete: Exit $EXIT_CODE (Failed) ══"
        RINGTONE error
    fi
    
    # Create management payload for viewing logs
    create_management_payload "$TASK_ID"
    
    # Post-completion menu
    LOG yellow "# LEFT:View | RIGHT:Export | DOWN:Delete Task #"
    LOG yellow "#->"
    
    resp=$(WAIT_FOR_INPUT)
    case $? in
        $DUCKYSCRIPT_CANCELLED)
            exit $EXIT_CODE
            ;;
        $DUCKYSCRIPT_REJECTED|$DUCKYSCRIPT_ERROR)
            LOG red "Error"
            exit $EXIT_CODE
            ;;
    esac
    
    case "$resp" in
        "LEFT")
            RINGTONE getkey
            LOG cyan "#--> View log"
            ;;
        "RIGHT")
            # Export log
            RINGTONE getkey
            LOG cyan "#--> Export log"
            if [ -f "$TASK_LOG" ]; then
                LOG blue $(/bin/bash "$METAPAYLOAD_DIR/scripts/export_task_log.sh" "$TASK_ID" 2>&1) >> "$TASK_LOG"
            else
                LOG red "No log file found"
            fi
            WAIT_FOR_BUTTON_PRESS
            ;;
        "DOWN")
            # Delete task
            RINGTONE bonus
            LOG cyan "#--> Delete task..."
            resp=$(CONFIRMATION_DIALOG "Delete this task?" "This will remove all task data")
            case $? in
                $DUCKYSCRIPT_REJECTED|$DUCKYSCRIPT_ERROR)
                    LOG red "Error in dialog"
                    ;;
                *)
                    case "$resp" in
                        $DUCKYSCRIPT_USER_CONFIRMED)
                            rm -f "$TASK_LOG" "$TASK_META"
                            mgmt_payload_dir="$MGMT_DIR/View_Task_${TASK_ID}"
                            rm -rf "$mgmt_payload_dir"
                            LOG green "Task deleted"
                            ;;
                        $DUCKYSCRIPT_USER_DENIED)
                            LOG "Cancelled"
                            ;;
                    esac
                    ;;
            esac
            ;;
        "B")
            RINGTONE bonus
            ;;
    esac
    
    exit $EXIT_CODE
fi
EXEC_CMD_END

    # chmod +x "$payload_file" # executable not needed for the pager
    LOG green "Generated: $path"
    
}

# Function to generate Set_Variables payloads
generate_set_variable_payload() {
    local var_name="$1"
    local payload_dir="$METAPAYLOAD_DIR/Set_$var_name"
    local payload_file="$payload_dir/payload.sh"
    
    mkdir -p "$payload_dir"
    
    cat > "$payload_file" << 'SET_VAR_SCRIPT'
#!/bin/bash
# Title: Set {{VAR_NAME}}
# Description: Set global variable {{VAR_NAME}}
# Author: MetaPayload
# Version: 1.0

METAPAYLOAD_DIR="/root/payloads/user/metapayload"
VAR_NAME="{{VAR_NAME}}"

# Load current value
if [ -f "$METAPAYLOAD_DIR/.env" ]; then
    source "$METAPAYLOAD_DIR/.env"
fi

CURRENT_VALUE="${!VAR_NAME}"

# Determine picker type
{{PICKER_LOGIC}}

# Prompt for new value
resp=$($PICKER_TYPE "Enter $VAR_NAME" "$CURRENT_VALUE")
case $? in
    $DUCKYSCRIPT_CANCELLED)
        LOG "Cancelled"
        exit 0
        ;;
    $DUCKYSCRIPT_REJECTED|$DUCKYSCRIPT_ERROR)
        LOG red "Error setting variable"
        exit 1
        ;;
esac

# Save to global .env
if grep -q "^${VAR_NAME}=" "$METAPAYLOAD_DIR/.env" 2>/dev/null; then
    sed -i "s|^${VAR_NAME}=.*|${VAR_NAME}=${resp}|" "$METAPAYLOAD_DIR/.env"
else
    echo "${VAR_NAME}=${resp}" >> "$METAPAYLOAD_DIR/.env"
fi

LOG green "Set $VAR_NAME=$resp"
exit 0
SET_VAR_SCRIPT

    # Detect picker type for this variable
    local picker_type=$(detect_picker_type "$var_name" "")
    local picker_logic="PICKER_TYPE=\"$picker_type\""
    
    sed -i "s|{{VAR_NAME}}|${var_name}|g" "$payload_file"
    sed -i "s|{{PICKER_LOGIC}}|${picker_logic}|g" "$payload_file"
    
    chmod +x "$payload_file"
}

# Extract all unique variables from all configs
declare -A ALL_VARS
for config_file in "$CONFIG_DIR"/*.json; do
    if [ ! -f "$config_file" ]; then
        continue
    fi
    
    LOG "Processing config: $(basename "$config_file")"
    
    # Read payloads from config
    payload_count=$(jq '.payloads | length' "$config_file")
    
    for ((i=0; i<$payload_count; i++)); do
        # Extract payload data
        name=$(jq -r ".payloads[$i].name" "$config_file")
        path=$(jq -r ".payloads[$i].path" "$config_file")
        command=$(jq -r ".payloads[$i].command" "$config_file")
        required_vars=$(jq -c ".payloads[$i].required_vars" "$config_file")
        optional_vars=$(jq -c ".payloads[$i].optional_vars" "$config_file")
        description=$(jq -r ".payloads[$i].description" "$config_file")
        author=$(jq -r ".payloads[$i].author" "$config_file")
        required_packages=$(jq -c ".payloads[$i].required_packages" "$config_file")
        
        # Collect variables
        if [ "$required_vars" != "null" ]; then
            echo "$required_vars" | jq -r '.[]' | while read -r var; do
                ALL_VARS["$var"]=1
            done
        fi
        
        if [ "$optional_vars" != "null" ]; then
            echo "$optional_vars" | jq -r 'keys[]' | while read -r var; do
                ALL_VARS["$var"]=1
            done
        fi
        
        # Generate the payload
        generate_payload "$name" "$path" "$command" "$required_vars" "$optional_vars" "$description" "$author" "$required_packages" 
    done
done

# Initialize .env if it doesn't exist
if [ ! -f "$ENV_FILE" ]; then
    LOG "Creating global .env file from example.env..."
    if [ -f "$METAPAYLOAD_DIR/example.env" ]; then
        # Copy and trim whitespace/line endings from values
        while IFS='=' read -r key value; do
            # Skip empty lines and comments
            [[ -z "$key" || "$key" =~ ^# ]] && continue
            # Trim whitespace and carriage returns from value
            value=$(echo "$value" | tr -d '\r' | xargs)
            echo "${key}=${value}" >> "$ENV_FILE"
        done < "$METAPAYLOAD_DIR/example.env"
        LOG green "Created .env from example.env"
    else
        LOG red "Warning: example.env not found at $METAPAYLOAD_DIR/example.env"
        exit 1
    fi
else
    LOG "Global .env already exists"
fi

# Generate Set_Variables payloads for all vars in .env
LOG "Generating Set_Variables payloads..."
if [ -f "$ENV_FILE" ]; then
    while IFS='=' read -r var_name _; do
        if [ -n "$var_name" ] && [[ ! "$var_name" =~ ^# ]]; then
            generate_set_variable_payload "$var_name"
        fi
    done < "$ENV_FILE"
fi

LOG green "Payload generation complete!"
exit 0
