#!/bin/bash
# Title: Generate Payloads
# Description: Generates HostHawk reconnaissance payloads from configuration files
# Author: spencershepard (GRIMM)
# Version: 1.0


HOSTHAWK_DIR="/root/payloads/user/HostHawk"
CONFIG_DIR="$HOSTHAWK_DIR/config"
PAYLOADS_DIR="/root/payloads"
ENV_FILE="$HOSTHAWK_DIR/.env"

LOG "Starting HostHawk payload generation..."

# Verify config directory exists
if [ ! -d "$CONFIG_DIR" ]; then
    LOG red "Error: Config directory not found at $CONFIG_DIR"
    exit 1
fi

# Function to detect picker type for a variable
detect_picker_type() {
    local var_name="$1"
    local default_value="$2"
    
    # If we have a default value, check its pattern
    if [ -n "$default_value" ]; then
        # IP pattern (basic check)
        if [[ "$default_value" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}(/[0-9]{1,2})?$ ]]; then
            echo "IP_PICKER"
            return
        fi
        
        # MAC pattern
        if [[ "$default_value" =~ ^([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}$ ]]; then
            echo "MAC_PICKER"
            return
        fi
        
        # Numeric pattern
        if [[ "$default_value" =~ ^[0-9]+$ ]]; then
            echo "NUMBER_PICKER"
            return
        fi
    else
        # No default, check variable name
        local upper_name=$(echo "$var_name" | tr '[:lower:]' '[:upper:]')
        
        if [[ "$upper_name" =~ IP|HOST|GATEWAY|SUBNET ]]; then
            echo "IP_PICKER"
            return
        fi
        
        if [[ "$upper_name" =~ MAC ]]; then
            echo "MAC_PICKER"
            return
        fi
    fi
    
    echo "TEXT_PICKER"
}

# Function to generate a payload script
generate_payload() {
    local name="$1"
    local path="$2"
    local command="$3"
    local required_vars="$4"
    local optional_vars="$5"
    local description="$6"
    local author="$7"
    local required_packages="$8"
    
    local payload_dir="$PAYLOADS_DIR/$path"
    local payload_file="$payload_dir/payload.sh"
    
    # Collect all variables for this payload
    local all_vars_list=""
    if [ -n "$required_vars" ] && [ "$required_vars" != "null" ]; then
        all_vars_list=$(echo "$required_vars" | jq -r '.[]' | tr '\n' ' ')
    fi
    if [ -n "$optional_vars" ] && [ "$optional_vars" != "null" ]; then
        all_vars_list="$all_vars_list $(echo "$optional_vars" | jq -r 'keys[]' | tr '\n' ' ')"
    fi
    
    # Create directory structure
    mkdir -p "$payload_dir"
    
    # Start building the payload script
    cat > "$payload_file" << 'PAYLOAD_HEADER'
#!/bin/bash
# Title: {{NAME}}
# Description: {{DESCRIPTION}}
# Author: {{AUTHOR}}
# Version: 1.0
# Generated by HostHawk

HOSTHAWK_DIR="/root/payloads/user/HostHawk"
PAYLOAD_DIR="{{PAYLOAD_DIR}}"
PAYLOAD_ENV="{{PAYLOAD_DIR}}/.env"

# Load global variables
if [ -f "$HOSTHAWK_DIR/.env" ]; then
    set -a
    source "$HOSTHAWK_DIR/.env"
    set +a
fi

# Load payload-specific variables
if [ -f "$PAYLOAD_ENV" ]; then
    set -a
    source "$PAYLOAD_ENV"
    set +a
fi

# Trim whitespace from all loaded variables
{{TRIM_VARS}}

# Function to check if variable is global
is_global_var() {
    local var_name="$1"
    grep -q "^${var_name}=" "$HOSTHAWK_DIR/.env" 2>/dev/null
}

# Function to save variable
save_var() {
    local var_name="$1"
    local var_value="$2"
    
    if is_global_var "$var_name"; then
        # Save to global .env
        if grep -q "^${var_name}=" "$HOSTHAWK_DIR/.env" 2>/dev/null; then
            sed -i "s|^${var_name}=.*|${var_name}=${var_value}|" "$HOSTHAWK_DIR/.env"
        else
            echo "${var_name}=${var_value}" >> "$HOSTHAWK_DIR/.env"
        fi
    else
        # Save to payload .env
        mkdir -p "$PAYLOAD_DIR"
        if grep -q "^${var_name}=" "$PAYLOAD_ENV" 2>/dev/null; then
            sed -i "s|^${var_name}=.*|${var_name}=${var_value}|" "$PAYLOAD_ENV"
        else
            echo "${var_name}=${var_value}" >> "$PAYLOAD_ENV"
        fi
    fi
}

PAYLOAD_HEADER

    # Replace placeholders in header
    sed -i "s|{{NAME}}|${name}|g" "$payload_file"
    sed -i "s|{{DESCRIPTION}}|${description}|g" "$payload_file"
    sed -i "s|{{AUTHOR}}|${author}|g" "$payload_file"
    sed -i "s|{{PAYLOAD_DIR}}|${payload_dir}|g" "$payload_file"
    
    # Add variable trimming code for this payload's variables
    if [ -n "$all_vars_list" ]; then
        cat >> "$payload_file" << 'TRIM_CODE'
for var in {{VAR_LIST}}; do
    if [ -n "${!var}" ]; then
        # Trim leading/trailing whitespace and carriage returns
        eval "export $var=\"\$(echo \"\${!var}\" | tr -d '\\r' | xargs)\""
    fi
done

TRIM_CODE
        sed -i "s|{{VAR_LIST}}|$all_vars_list|g" "$payload_file"
    fi
    
    # Remove the placeholder line
    sed -i '/{{TRIM_VARS}}/d' "$payload_file"
    
    # Build metadata for confirmation dialog
    cat >> "$payload_file" << 'METADATA_START'

# Build metadata string
METADATA="Description: {{DESCRIPTION}}
Author: {{AUTHOR}}

Required Variables:"
METADATA_START
    
    sed -i "s|{{DESCRIPTION}}|${description}|g" "$payload_file"
    sed -i "s|{{AUTHOR}}|${author}|g" "$payload_file"
    
    # Add required vars to metadata
    if [ -n "$required_vars" ] && [ "$required_vars" != "null" ]; then
        echo "$required_vars" | jq -r '.[]' | while read -r var; do
            echo "METADATA=\"\$METADATA" >> "$payload_file"
            echo "  $var: \${$var:-<not set>}\"" >> "$payload_file"
        done
    fi
    
    # Add optional vars to metadata
    cat >> "$payload_file" << 'METADATA_OPTIONAL'

METADATA="$METADATA

Optional Variables:"
METADATA_OPTIONAL
    
    if [ -n "$optional_vars" ] && [ "$optional_vars" != "null" ]; then
        echo "$optional_vars" | jq -r 'to_entries[] | "\(.key)=\(.value)"' | while IFS='=' read -r var default; do
            echo "METADATA=\"\$METADATA" >> "$payload_file"
            echo "  $var: \${$var:-$default}\"" >> "$payload_file"
        done
    fi
    
    # Confirmation dialog
    cat >> "$payload_file" << 'CONFIRMATION'

# Show confirmation dialog
resp=$(CONFIRMATION_DIALOG "$METADATA")
case $? in
    $DUCKYSCRIPT_REJECTED)
        LOG red "Payload cancelled"
        exit 1
        ;;
    $DUCKYSCRIPT_ERROR)
        LOG red "An error occurred"
        exit 1
        ;;
esac

case "$resp" in
    $DUCKYSCRIPT_USER_DENIED)
        LOG "Payload cancelled by user"
        exit 0
        ;;
esac

CONFIRMATION

    # Add package checking and installation
    if [ -n "$required_packages" ] && [ "$required_packages" != "null" ] && [ "$required_packages" != "[]" ]; then
        cat >> "$payload_file" << 'PKG_CHECK_START'

# Check and install required packages
REQUIRED_PACKAGES=({{PACKAGE_LIST}})
MISSING_PACKAGES=()

LOG "Checking required packages..."
for pkg in "${REQUIRED_PACKAGES[@]}"; do
    if ! opkg list-installed | grep -q "^${pkg} "; then
        LOG yellow "Package not installed: $pkg"
        MISSING_PACKAGES+=("$pkg")
    else
        LOG green "Package installed: $pkg"
    fi
done

if [ ${#MISSING_PACKAGES[@]} -gt 0 ]; then
    pkg_list=$(printf ", %s" "${MISSING_PACKAGES[@]}")
    pkg_list=${pkg_list:2}
    
    resp=$(CONFIRMATION_DIALOG "Missing packages: ${pkg_list}\n\nInstall now?")
    case $? in
        $DUCKYSCRIPT_REJECTED|$DUCKYSCRIPT_ERROR)
            LOG red "Error in dialog"
            exit 1
            ;;
    esac
    
    case "$resp" in
        $DUCKYSCRIPT_USER_CONFIRMED)
            LOG "Installing packages..."
            opkg update
            for pkg in "${MISSING_PACKAGES[@]}"; do
                LOG "Installing $pkg..."
                opkg install "$pkg" 2>&1 | tee /tmp/opkg_install.log
                
                # Check if package is actually installed
                if opkg list-installed | grep -q "^${pkg} "; then
                    LOG green "Successfully installed $pkg"
                else
                    LOG red "Failed to install $pkg (package not found in installed list)"
                    LOG red "$(cat /tmp/opkg_install.log)"
                    exit 1
                fi
            done
            LOG green "All packages installed successfully"
            ;;
        *)
            LOG red "Cannot continue without required packages"
            exit 1
            ;;
    esac
fi

PKG_CHECK_START
        
        # Replace package list placeholder
        local pkg_list=$(echo "$required_packages" | jq -r '.[]' | tr '\n' ' ')
        sed -i "s|{{PACKAGE_LIST}}|$pkg_list|g" "$payload_file"
    fi

    # Add required variable checking
    if [ -n "$required_vars" ] && [ "$required_vars" != "null" ]; then
        echo "$required_vars" | jq -r '.[]' | while read -r var; do
            local picker_type=$(detect_picker_type "$var" "")
            
            cat >> "$payload_file" << VAR_CHECK
# Check required variable: $var
if [ -z "\${$var}" ]; then
    resp=\$($picker_type "Enter $var" "")
    case \$? in
        \$DUCKYSCRIPT_CANCELLED|\$DUCKYSCRIPT_REJECTED|\$DUCKYSCRIPT_ERROR)
            LOG red "Cancelled or error setting $var"
            exit 1
            ;;
    esac
    export $var="\$resp"
    save_var "$var" "\$resp"
fi

VAR_CHECK
        done
    fi
    
    # Add optional variable handling
    if [ -n "$optional_vars" ] && [ "$optional_vars" != "null" ]; then
        # Add general confirmation for changing optional vars
        cat >> "$payload_file" << 'OPT_VAR_GENERAL'

# Ask if user wants to change any optional variables
change_optional=$(CONFIRMATION_DIALOG "Change optional variables?")
case $? in
    $DUCKYSCRIPT_REJECTED|$DUCKYSCRIPT_ERROR)
        LOG red "Error in dialog"
        exit 1
        ;;
esac

OPT_VAR_GENERAL

        # Set defaults first
        echo "$optional_vars" | jq -r 'to_entries[] | "\(.key)=\(.value)"' | while IFS='=' read -r var default; do
            cat >> "$payload_file" << OPT_VAR_DEFAULT
# Set default for optional variable: $var
if [ -z "\${$var}" ]; then
    export $var="$default"
fi

OPT_VAR_DEFAULT
        done
        
        # Only ask about individual vars if user confirmed
        cat >> "$payload_file" << 'OPT_VAR_CHECK_START'
# Only ask about individual optional vars if user wants to change them
if [ "$change_optional" == "$DUCKYSCRIPT_USER_CONFIRMED" ]; then
OPT_VAR_CHECK_START

        echo "$optional_vars" | jq -r 'to_entries[] | "\(.key)=\(.value)"' | while IFS='=' read -r var default; do
            local picker_type=$(detect_picker_type "$var" "$default")
            
            cat >> "$payload_file" << OPT_VAR_CHECK
    # Ask about optional variable: $var
    resp=\$(CONFIRMATION_DIALOG "Change $var? (current: \${$var})")
    case \$? in
        \$DUCKYSCRIPT_REJECTED|\$DUCKYSCRIPT_ERROR)
            LOG red "Error in dialog"
            exit 1
            ;;
    esac
    
    case "\$resp" in
        \$DUCKYSCRIPT_USER_CONFIRMED)
            resp=\$($picker_type "Enter $var" "\${$var}")
            case \$? in
                \$DUCKYSCRIPT_CANCELLED|\$DUCKYSCRIPT_REJECTED|\$DUCKYSCRIPT_ERROR)
                    LOG "Keeping current value for $var"
                    ;;
                *)
                    export $var="\$resp"
                    
                    # Ask if they want to save it
                    save_resp=\$(CONFIRMATION_DIALOG "Save $var for next time?")
                    case \$save_resp in
                        \$DUCKYSCRIPT_USER_CONFIRMED)
                            save_var "$var" "\$resp"
                            LOG green "Saved $var"
                            ;;
                        *)
                            LOG "Using $var for this run only"
                            ;;
                    esac
                    ;;
            esac
            ;;
    esac

OPT_VAR_CHECK
        done
        
        # Close the if statement
        cat >> "$payload_file" << 'OPT_VAR_CHECK_END'
fi

OPT_VAR_CHECK_END
    fi
    
    # Add command execution
    cat >> "$payload_file" << 'EXEC_CMD'

# Execute command
EXEC_CMD
    
    # Properly escape the command for the payload script
    printf 'CMD="%s"\n' "$command" >> "$payload_file"
    
    cat >> "$payload_file" << 'EXEC_CMD_END'
LOG purple "$CMD"

OUTPUT=$(eval "$CMD" 2>&1)
EXIT_CODE=$?

# Log results
if [ $EXIT_CODE -eq 0 ]; then
    LOG green "Command completed successfully"
    LOG green "$OUTPUT"
else
    LOG red "Command failed with exit code $EXIT_CODE"
    LOG red "$OUTPUT"
fi

exit $EXIT_CODE
EXEC_CMD_END

    chmod +x "$payload_file"
    LOG green "Generated: $path"
    
}

# Function to generate Set_Variables payloads
generate_set_variable_payload() {
    local var_name="$1"
    local payload_dir="$HOSTHAWK_DIR/Set_$var_name"
    local payload_file="$payload_dir/payload.sh"
    
    mkdir -p "$payload_dir"
    
    cat > "$payload_file" << 'SET_VAR_SCRIPT'
#!/bin/bash
# Title: Set {{VAR_NAME}}
# Description: Set global variable {{VAR_NAME}}
# Author: HostHawk
# Version: 1.0

HOSTHAWK_DIR="/root/payloads/user/HostHawk"
VAR_NAME="{{VAR_NAME}}"

# Load current value
if [ -f "$HOSTHAWK_DIR/.env" ]; then
    source "$HOSTHAWK_DIR/.env"
fi

CURRENT_VALUE="${!VAR_NAME}"

# Determine picker type
{{PICKER_LOGIC}}

# Prompt for new value
resp=$($PICKER_TYPE "Enter $VAR_NAME" "$CURRENT_VALUE")
case $? in
    $DUCKYSCRIPT_CANCELLED)
        LOG "Cancelled"
        exit 0
        ;;
    $DUCKYSCRIPT_REJECTED|$DUCKYSCRIPT_ERROR)
        LOG red "Error setting variable"
        exit 1
        ;;
esac

# Save to global .env
if grep -q "^${VAR_NAME}=" "$HOSTHAWK_DIR/.env" 2>/dev/null; then
    sed -i "s|^${VAR_NAME}=.*|${VAR_NAME}=${resp}|" "$HOSTHAWK_DIR/.env"
else
    echo "${VAR_NAME}=${resp}" >> "$HOSTHAWK_DIR/.env"
fi

LOG green "Set $VAR_NAME=$resp"
exit 0
SET_VAR_SCRIPT

    # Detect picker type for this variable
    local picker_type=$(detect_picker_type "$var_name" "")
    local picker_logic="PICKER_TYPE=\"$picker_type\""
    
    sed -i "s|{{VAR_NAME}}|${var_name}|g" "$payload_file"
    sed -i "s|{{PICKER_LOGIC}}|${picker_logic}|g" "$payload_file"
    
    chmod +x "$payload_file"
}

# Extract all unique variables from all configs
declare -A ALL_VARS
for config_file in "$CONFIG_DIR"/*.json; do
    if [ ! -f "$config_file" ]; then
        continue
    fi
    
    LOG "Processing config: $(basename "$config_file")"
    
    # Read payloads from config
    payload_count=$(jq '.payloads | length' "$config_file")
    
    for ((i=0; i<$payload_count; i++)); do
        # Extract payload data
        name=$(jq -r ".payloads[$i].name" "$config_file")
        path=$(jq -r ".payloads[$i].path" "$config_file")
        command=$(jq -r ".payloads[$i].command" "$config_file")
        required_vars=$(jq -c ".payloads[$i].required_vars" "$config_file")
        optional_vars=$(jq -c ".payloads[$i].optional_vars" "$config_file")
        description=$(jq -r ".payloads[$i].description" "$config_file")
        author=$(jq -r ".payloads[$i].author" "$config_file")
        required_packages=$(jq -c ".payloads[$i].required_packages" "$config_file")
        
        # Collect variables
        if [ "$required_vars" != "null" ]; then
            echo "$required_vars" | jq -r '.[]' | while read -r var; do
                ALL_VARS["$var"]=1
            done
        fi
        
        if [ "$optional_vars" != "null" ]; then
            echo "$optional_vars" | jq -r 'keys[]' | while read -r var; do
                ALL_VARS["$var"]=1
            done
        fi
        
        # Generate the payload
        generate_payload "$name" "$path" "$command" "$required_vars" "$optional_vars" "$description" "$author" "$required_packages" 
    done
done

# Initialize .env if it doesn't exist
if [ ! -f "$ENV_FILE" ]; then
    LOG "Creating global .env file from example.env..."
    if [ -f "$HOSTHAWK_DIR/example.env" ]; then
        # Copy and trim whitespace/line endings from values
        while IFS='=' read -r key value; do
            # Skip empty lines and comments
            [[ -z "$key" || "$key" =~ ^# ]] && continue
            # Trim whitespace and carriage returns from value
            value=$(echo "$value" | tr -d '\r' | xargs)
            echo "${key}=${value}" >> "$ENV_FILE"
        done < "$HOSTHAWK_DIR/example.env"
        LOG green "Created .env from example.env"
    else
        LOG red "Warning: example.env not found at $HOSTHAWK_DIR/example.env"
        exit 1
    fi
else
    LOG "Global .env already exists"
fi

# Generate Set_Variables payloads for all vars in .env
LOG "Generating Set_Variables payloads..."
if [ -f "$ENV_FILE" ]; then
    while IFS='=' read -r var_name _; do
        if [ -n "$var_name" ] && [[ ! "$var_name" =~ ^# ]]; then
            generate_set_variable_payload "$var_name"
        fi
    done < "$ENV_FILE"
fi

LOG green "Payload generation complete!"
exit 0
